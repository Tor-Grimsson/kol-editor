# 1.0.2 Penpot Architecture Analysis

## Overview

Analyzed Penpot's codebase to understand how they solve the Canvas = Layer relationship and implement transformation/ruler systems.

## Key Architectural Patterns

### 1. Flat Object Map (Single Source of Truth)

**Penpot's approach:**
```clojure
;; ALL shapes (including frames) in ONE flat map
objects: {
  "uuid-frame-1": {
    :id "uuid-frame-1"
    :type :frame
    :x 0
    :y 0
    :width 1200
    :height 800
    :shapes ["uuid-rect-1", "uuid-circle-1"]  ; child IDs
    :frame-id uuid/zero  ; root frame reference
    :parent-id uuid/zero
  },
  "uuid-rect-1": {
    :id "uuid-rect-1"
    :type :rect
    :x 100
    :y 100
    :width 200
    :height 150
    :frame-id "uuid-frame-1"  ; which frame contains this
    :parent-id "uuid-frame-1"
  }
}
```

**Key insight:** Frame IS a shape with `type: :frame`. There's no separate "canvas" or "layer" entity.

**Files:**
- `common/src/app/common/types/shape.cljc` - Shape definition (line 46-48)
- `common/src/app/common/files/helpers.cljc` - `frame-shape?` predicate (line 48-53)

### 2. No Duplicate State

**What Penpot DOESN'T have:**
```js
// ❌ No separate state for canvas properties
canvasSize: { width, height }     // DOESN'T EXIST
artboardPosition: { x, y }         // DOESN'T EXIST
```

**Instead:** All canvas properties derived directly from the frame shape in the objects map.

When you select a frame:
- Canvas dimensions = `objects[frame-id].width` / `objects[frame-id].height`
- Canvas position = `objects[frame-id].x` / `objects[frame-id].y`
- Render frame's children = `objects[frame-id].shapes.map(id => objects[id])`

**Source of truth:** The frame object itself. No syncing needed.

### 3. Transformation System

**How Penpot handles shape/frame movement:**

**Location:** `frontend/src/app/main/data/workspace/transforms.cljs`

**Pattern: Modifier Trees + Delta Transforms**

```clojure
;; Update position (lines 1013-1051)
(defn update-position [id position options]
  ;; 1. Get shape from objects map
  (let [shape (get objects id)

        ;; 2. Calculate delta from current position
        bbox  (-> shape :points grc/points->rect)
        delta (calculate-delta position bbox frame)

        ;; 3. Create modifier tree for all affected shapes
        modifiers (dwm/create-modif-tree [id] (ctm/move-modifiers delta))]

    ;; 4. Apply modifiers (returns new objects map)
    (dwm/apply-modifiers {:modifiers modifiers :page-id page-id})))
```

**Key concepts:**

1. **Delta-based:** Calculate movement delta, apply to shape and all children
2. **Modifier trees:** Transform hierarchies (frame + children) atomically
3. **Immutable updates:** Never mutate `objects` map, return new version
4. **Constraint resolution:** Handles layout constraints, snapping, parent bounds

**Frame resize (lines 146-150, 54-92):**
- Uses resize handlers (8 directions: corners + edges)
- Calculates resize origin (opposite corner)
- Applies multipliers per direction
- Maintains aspect ratio with shift key

### 4. Ruler Implementation

**Location:** `frontend/src/app/main/ui/workspace/viewport/rulers.cljs`

**Dynamic step sizing based on zoom:**

```clojure
(defn calculate-step-size [zoom]
  (cond
    (< 0 zoom 0.008)    10000  ; Very zoomed out
    (< 0.008 zoom 0.015) 5000
    (< 0.015 zoom 0.04)  2500
    (< 0.04 zoom 0.07)   1000
    (< 0.07 zoom 0.2)     500
    (< 0.2 zoom 0.5)      250
    (< 0.5 zoom 1)        100
    (<= 1 zoom 2)          50  ; Default zoom
    (< 2 zoom 4)           25
    (< 4 zoom 6)           10
    (< 6 zoom 15)           5
    (< 15 zoom 25)          2
    (< 25 zoom)             1  ; Very zoomed in
    :else 1))
```

**Ruler rendering (lines 145-150):**
- Calculates visible range from viewport bounds (vbox)
- Generates tick marks at step intervals
- Positions text labels with zoom-inverse scaling
- Uses SVG clip paths for ruler areas

**Performance:** Memoized calculations, only re-renders on zoom/pan changes

### 5. Viewport & Coordinate System

**Location:** `frontend/src/app/main/ui/workspace/viewport.cljs`

**State structure (lines 84-96):**
```clojure
workspace-local: {
  :vbox          ; Visible bounding box in canvas coords
  :vport         ; Viewport DOM dimensions
  :zoom          ; Current zoom level (1 = 100%)
  :zoom-inverse  ; 1/zoom for reverse calculations
  :panning       ; Pan drag state
  :transform     ; Current transform operation
}
```

**Coordinate spaces:**
1. **Canvas space:** Shape coordinates (frame.x, frame.y)
2. **Viewport space:** Screen pixels
3. **Conversion:** `canvas-coord * zoom + viewport-offset`

**vbox (viewport bounding box):**
```clojure
{:x 0           ; Top-left canvas coordinate visible
 :y 0
 :width 2000    ; Canvas units visible (not pixels)
 :height 1200}
```

### 6. Shape Rendering

**Location:** `frontend/src/app/main/ui/workspace/shapes/frame.cljs`

**Frame as container (lines 40-50):**
```clojure
(mf/defc frame-shape-inner [props ref]
  (let [shape    (unchecked-get props "shape")
        shape-id (dm/get-prop shape :id)

        ;; Get children from objects map
        childs   (mf/deref (refs/children-objects shape-id))]

    [:& shape-container {:shape shape :ref ref}
     [:& frame-shape {:shape shape :childs childs}]]))
```

**Renders:**
1. Frame background/border
2. All child shapes recursively
3. Layout grids (if frame has layout)
4. Selection overlays

## Applying to KolEditor

### Current Problems

**❌ Current architecture:**
```js
// Duplicate state
layers: [{ id, frame: {x, y, width, height}, objects: [...] }]
canvasSize: { width, height }      // Duplicates frame.width/height
artboardPosition: { x, y }         // Duplicates frame.x/y
selectedLayerId: "canvas-1"

// Sync issues (lines 101-113 in KolEditor.jsx)
useEffect(() => {
  const selectedCanvas = layers.find(layer => layer.id === selectedLayerId)
  if (!selectedCanvas) return

  // Manually sync canvas state from layer
  if (frame.x !== artboardPosition.x) setArtboardPosition(...)
  if (frame.width !== canvasSize.width) setCanvasSize(...)
}, [selectedLayerId, layers])
```

**Problem:** Canvas and Layer can drift out of sync. Requires manual synchronization.

### Proposed Refactor

**✅ New architecture (Penpot-inspired):**

```js
// 1. Flat shapes map (single source of truth)
const [shapes, setShapes] = useState({})  // Map<id, shape>

// 2. Selection points to shape
const [selectedShapeId, setSelectedShapeId] = useState(null)

// 3. Derive canvas properties from selected frame
const selectedFrame = useMemo(() => {
  return shapes[selectedShapeId]
}, [shapes, selectedShapeId])

// Canvas size = frame size (NO separate state)
const canvasSize = selectedFrame
  ? { width: selectedFrame.width, height: selectedFrame.height }
  : { width: 1200, height: 800 }

// Canvas position = frame position (NO separate state)
const canvasPosition = selectedFrame
  ? { x: selectedFrame.x, y: selectedFrame.y }
  : { x: 0, y: 0 }

// 4. Render selected frame's children
const visibleShapes = useMemo(() => {
  if (!selectedFrame) return []
  return selectedFrame.children.map(id => shapes[id]).filter(Boolean)
}, [shapes, selectedFrame])
```

**Shape structure:**
```js
// Frame (canvas) shape
{
  id: "frame-1",
  type: "frame",
  name: "Canvas 1",
  x: 0,
  y: 0,
  width: 1200,
  height: 800,
  rotation: 0,
  background: "#18181b",
  visible: true,
  children: ["rect-1", "circle-1"],  // Child shape IDs
  frameId: null,    // Root frame
  parentId: null
}

// Child shape
{
  id: "rect-1",
  type: "rect",
  name: "Rectangle 1",
  x: 100,
  y: 100,
  width: 200,
  height: 150,
  rotation: 0,
  color: "#3b82f6",
  visible: true,
  children: [],
  frameId: "frame-1",    // Which frame contains this
  parentId: "frame-1"
}
```

### Benefits

1. **No sync issues:** Canvas properties ARE frame properties
2. **Single source of truth:** All shape data in one map
3. **Efficient updates:** Immutable updates, only changed shapes re-render
4. **Scalability:** Handles thousands of shapes efficiently
5. **Undo/redo:** Simple snapshot system (serialize shapes map)
6. **Multi-canvas:** Multiple frames = multiple "canvases" naturally

### Migration Steps

**Phase 1: Data structure**
1. Convert `layers` array → `shapes` object
2. Remove `canvasSize` and `artboardPosition` state
3. Derive canvas properties from `shapes[selectedShapeId]`

**Phase 2: Update functions**
1. Rewrite `appendObjectToLayer` → `addShapeToFrame`
2. Rewrite `updateObjectFrame` → `updateShape`
3. Use immutable updates: `setShapes(prev => ({ ...prev, [id]: newShape }))`

**Phase 3: Rendering**
1. Update CanvasArea to accept frame shape directly
2. Render only selected frame's children
3. Remove layer syncing useEffect

**Phase 4: Transformations**
1. Implement delta-based movement
2. Add resize handlers for frames
3. Handle hierarchy (frame + children move together)

## Ruler System Recommendations

**Adopt Penpot's zoom-adaptive step sizing:**

```js
const getRulerStep = (zoom) => {
  if (zoom < 0.04) return 2500
  if (zoom < 0.2) return 500
  if (zoom < 0.5) return 250
  if (zoom < 1) return 100
  if (zoom <= 2) return 50
  if (zoom < 4) return 25
  if (zoom < 6) return 10
  return 5
}
```

**Current issue:** Fixed 100px step becomes cluttered at high zoom, sparse at low zoom.

**Fix:** Dynamic steps maintain ~50-100px visual spacing regardless of zoom.

## Key Takeaways

1. **Frame = Shape with type "frame":** Not a special entity
2. **Flat object map:** Better than nested arrays for performance
3. **No duplicate state:** Derive everything from single source
4. **Delta transforms:** Calculate movement delta, apply to tree
5. **Immutable updates:** Never mutate, always return new state
6. **Zoom-adaptive UI:** Rulers, grids adapt to zoom level

## Files to Reference

**Data model:**
- `common/src/app/common/types/shape.cljc` (shape definition)
- `common/src/app/common/files/helpers.cljc` (shape predicates)

**Transformations:**
- `frontend/src/app/main/data/workspace/transforms.cljs` (move, resize)

**Rendering:**
- `frontend/src/app/main/ui/workspace/viewport.cljs` (viewport state)
- `frontend/src/app/main/ui/workspace/shapes/frame.cljs` (frame rendering)
- `frontend/src/app/main/ui/workspace/viewport/rulers.cljs` (ruler implementation)

## Next Steps

1. Create refactor plan with concrete code changes
2. Implement data structure migration (backwards compatible)
3. Update rendering to use new structure
4. Remove old sync code
5. Test multi-canvas workflows
