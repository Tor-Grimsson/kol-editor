# 1.1.0 Foundation: Build System

**Version:** 1.0.0
**Date:** 2025-11-03
**Status:** Active
**Content Type:** implementation
**Category:** foundation

---

## Overview

This document describes the kolkrabbi monorepo build system, powered by Turborepo for task orchestration and package dependency management. The build system supports parallel execution, intelligent caching, and incremental builds across all packages and applications.

---

## Architecture

### Core Technologies

**Turborepo:**
- Task orchestration and caching
- Parallel execution of independent tasks
- Dependency graph awareness
- Remote caching for CI/CD

**Yarn (Berry):**
- Package management
- Workspace support
- Plug'n'Play (PnP) resolution
- Single lockfile for entire monorepo

**Build Tools:**
- **Vite** - Fast development server and bundler for web apps
- **Sanity CLI** - Build and deploy Studio
- **tsup** - TypeScript package bundling
- **ESLint** - Code linting
- **Prettier** - Code formatting

### Build Pipeline

```
┌─────────────────────────────────────────┐
│           turborepo pipeline            │
└─────────────────────────────────────────┘

    ┌─────────────┐
    │   yarn      │  → Install dependencies
    │  install    │
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐       ┌─────────────┐
    │   Turbo     │  ────▶│  Build UI   │  → Build packages/ui
    │   Build     │       │  Package    │
    └──────┬──────┘       └─────────────┘
           │
           ├─────────────────┬─────────────────┬─────────────▶
           ▼                 ▼                 ▼
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │   Build     │  │   Build     │  │   Build     │
    │   Web App   │  │   Studio    │  │  FontViewer │
    └──────┬──────┘  └─────────────┘  └─────────────┘
           │
           ▼
    ┌─────────────┐
    │   Deploy    │  → Deploy to production
    │   Artifacts │
    └─────────────┘
```

---

## Configuration

### Root package.json

**Workspaces configuration:**
```json
{
  "name": "kolkrabbi-monorepo",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev:web": "turbo run dev --filter=web",
    "dev:studio": "turbo run dev --filter=studio",
    "build": "turbo run build",
    "lint": "turbo run lint",
    "typecheck": "turbo run typecheck",
    "clean": "turbo run clean"
  },
  "devDependencies": {
    "turbo": "^1.13.0",
    "eslint": "^9.11.0",
    "prettier": "^3.3.3"
  }
}
```

### turborepo.json

**Pipeline configuration:**
```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [
        "dist/**",
        "build/**",
        ".next/**",
        "!.next/cache/**"
      ]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {
      "outputs": []
    },
    "typecheck": {
      "outputs": []
    },
    "clean": {
      "cache": false
    }
  }
}
```

**Pipeline rules:**

1. **dependsOn: ["^build"]**:
   - `^build` means "build all dependencies first"
   - Ensures packages are built in correct order
   - UI package builds before web app imports it

2. **outputs**:
   - Defines what files to cache
   - Turborepo caches these for reuse
   - Speeds up subsequent builds

3. **cache: false**:
   - `dev` tasks don't cache (always fresh)
   - `clean` tasks don't cache (one-time operations)

---

## Package Scripts

### apps/web/package.json

**Web app scripts:**
```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext .js,.jsx",
    "typecheck": "tsc --noEmit"
  }
}
```

**Development:**
```bash
# Start development server
yarn dev:web

# Output:
# - Fast HMR (Hot Module Replacement)
# - Vite dev server on port 5173
# - Instant rebuilds on file changes
```

**Build:**
```bash
# Production build
yarn build

# Output:
# - Optimized bundles
# - Minified code
# - Static assets to dist/
# - Ready for deployment
```

### apps/studio/package.json

**Studio scripts:**
```json
{
  "scripts": {
    "dev": "sanity dev",
    "build": "sanity build",
    "deploy": "sanity deploy",
    "typecheck": "tsc --noEmit"
  }
}
```

### packages/ui/package.json

**UI package scripts:**
```json
{
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "lint": "eslint src --ext .js,.jsx",
    "typecheck": "tsc --noEmit"
  },
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./css": "./css/theme.css"
  }
}
```

**Build with tsup:**
```bash
# Build UI package
yarn build

# Output:
# - CommonJS (index.js)
# - ES Modules (index.mjs)
# - TypeScript declarations (index.d.ts)
# - Ready to import in apps
```

---

## Build Commands

### Development

**Start all apps:**
```bash
# Run web in development
yarn dev:web

# Run studio in development
yarn dev:studio

# Run specific package
yarn workspace @kol/ui run dev
```

**What happens:**
1. Turborepo reads `turbo.json`
2. Finds `dev` scripts in packages
3. Runs them in parallel (or sequence if dependencies exist)
4. Vite starts dev server with HMR
5. Sanity Studio starts with watch mode
6. Changes trigger automatic rebuilds

### Production Build

**Build everything:**
```bash
yarn build
```

**Build specific app:**
```bash
yarn workspace web run build
yarn workspace studio run build
```

**What happens:**
1. Turborepo analyzes dependency graph
2. Starts with packages that have no dependencies
3. Builds packages in topological order
4. Each build caches output
5. Apps import built packages from `dist/`
6. Final output in each package's `dist/` folder

**Build order:**
```
packages/ui → packages/content → packages/fontviewer → apps/web, apps/studio
```

### Linting

**Lint everything:**
```bash
yarn lint
```

**Lint specific package:**
```bash
yarn workspace web run lint
```

**Auto-fix:**
```bash
yarn lint --fix
```

### Type Checking

**Type check everything:**
```bash
yarn typecheck
```

**Type check specific package:**
```bash
yarn workspace @kol/ui run typecheck
```

---

## Caching

### Local Caching

**Turborepo caches:**
- Build outputs in `.turbo/`
- Stores based on file contents and dependencies
- Reuses cache if inputs haven't changed

**View cache:**
```bash
turbo run build --dry-run
```

**Clear cache:**
```bash
turbo run clean
# or
rm -rf .turbo
```

### Remote Caching (CI/CD)

**Vercel Turborepo:**
```yaml
# .github/workflows/ci.yml
name: CI
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Setup Yarn
        run: corepack enable

      - name: Cache Turborepo
        uses: actions/cache@v3
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Lint
        run: yarn lint
```

**Cache key:**
- `runner.os` - Cache per OS (linux, windows, mac)
- `github.sha` - Cache per commit SHA
- Restore keys allow fallback to previous caches

---

## Build Optimization

### Parallel Builds

**Turborepo automatically:**
- Builds independent packages in parallel
- Respects dependency order when needed
- Maximizes CPU utilization

**Example:**
```
If packages have no dependencies on each other:
- packages/ui builds in parallel with packages/content
- Both finish, then apps can build

If package B depends on package A:
- packages/ui builds first
- packages/content waits for ui to finish
- Then packages/content builds
```

### Incremental Builds

**Rebuild only what changed:**
- Change `packages/ui/src/atoms/Button.jsx`
- Only rebuild `packages/ui`
- Apps that import Button get updated automatically
- `packages/content` doesn't rebuild (not affected)

**Build cache:**
- Stores output in `.turbo/`
- Checks if inputs changed (files, dependencies)
- Skips build if nothing changed
- Super fast rebuilds!

### Code Splitting

**Vite automatically:**
- Splits code into chunks
- Lazy loads non-critical code
- Optimizes bundle sizes

**Example:**
```javascript
// Route-based code splitting
const Work = lazy(() => import('../routes/Work.jsx'))
const Foundry = lazy(() => import('../routes/Foundry.jsx'))

// Component-based code splitting
const DataTable = lazy(() => import('../organisms/DataTable.jsx'))
```

---

## Troubleshooting

### Common Issues

**Build fails after dependency update:**
```bash
# Clear all caches
yarn clean
rm -rf node_modules
rm -rf .turbo
yarn install
yarn build
```

**Turborepo cache corrupted:**
```bash
# Clear specific cache
turbo run build --force
```

**Package import errors:**
```bash
# Rebuild specific package
yarn workspace @kol/ui run build

# Check exports in package.json
# Verify imports in consuming app
```

**Type errors:**
```bash
# Check TypeScript config
# Verify types are exported
yarn workspace @kol/ui run typecheck
```

### Debug Mode

**Verbose output:**
```bash
turbo run build --debug
```

**Dry run (see what would happen):**
```bash
turbo run build --dry-run
```

**Graph mode (see dependency graph):**
```bash
turbo run build --graph
```

---

## Best Practices

### 1. Build Only What You Need

**Develop web app only:**
```bash
yarn dev:web
# Only builds web, not studio or other packages
```

**Build specific package:**
```bash
yarn workspace @kol/ui run build
```

### 2. Keep Builds Fast

**Avoid unnecessary dependencies:**
- Don't import heavy libraries unnecessarily
- Use tree-shaking compatible imports
- Split code at route/component level

**Good:**
```javascript
import { debounce } from 'lodash-es'  // Tree-shakeable
import { Button } from '@kol/ui'      // ESM, tree-shakeable
```

**Bad:**
```javascript
import _ from 'lodash'                // Full library
import * as UI from '@kol/ui'         // Can't tree-shake
```

### 3. Use Cache Effectively

**Cache only build outputs:**
- Configure `outputs` in `turbo.json`
- Don't cache lint or test outputs
- Let Turborepo decide what to cache

### 4. Optimize for CI/CD

**Parallel CI jobs:**
```yaml
# .github/workflows/ci.yml
jobs:
  build:
    strategy:
      matrix:
        app: [web, studio]

  lint:
    runs-on: ubuntu-latest
    steps:
      - run: yarn lint

  typecheck:
    runs-on: ubuntu-latest
    steps:
      - run: yarn typecheck
```

**Cache node_modules and .turbo:**
```yaml
- uses: actions/cache@v3
  with:
    path: |
      .turbo
      node_modules
    key: ${{ runner.os }}-${{ hashFiles('yarn.lock') }}
```

---

## Related Documentation

**Foundation:**
- [1.0.0 Foundation: Repository Structure](1.0.0-foundation-repository-structure.md) - Project organization
- [1.0.1 Foundation: Naming Conventions](1.0.1-foundation-naming-conventions.md) - File and code conventions

**Design System:**
- [2.0.0 Design System: Overview](2.0.0-design-system-overview.md) - Design system principles

**Metadata:**
- [0.0.1 Metadata: Writing Guidelines](0.0.1-metadata-writing-guidelines.md) - Documentation standards

---

**Last Updated:** 2025-11-03
