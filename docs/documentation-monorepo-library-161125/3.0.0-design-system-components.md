# 3.0.0 Design System: Components Overview

**Version:** 1.0
**Date:** 2025-11-04
**Status:** Active
**Content Type:** implementation
**Category:** design-system

---

# Components Overview

**Purpose:** Atomic design methodology for building reusable UI components in the kolkrabbi design system.

> The kolkrabbi design system follows the atomic design methodology, organizing UI components into three hierarchical levels: **Atoms** (basic building blocks), **Molecules** (simple component combinations), and **Organisms** (complex, distinct sections). This methodology ensures consistency, scalability, and maintainability across all user interfaces.

## Chapter Index

| Number | Title | Focus |
|--------|-------|-------|
| `3.0.0` | Components Overview (this doc) | Atomic philosophy + guidance |
| `3.1.0` | Atoms | Catalog + specs |
| `3.2.0` | Molecules | Patterns composed from atoms |
| `3.3.0` | Organisms | Larger sections |
| `3.4.0` | Icons | Iconography + glyph usage |
| `5.3.2`–`5.3.5` | Workshop Apparatus | Specialty experiments (documented in the workshop chapter) |
| `3.7.0` | Templates Overview | How components roll into templates |

## Design Philosophy

1. **Composable Building Blocks** - Each component is designed to work independently and combine seamlessly with others
2. **Semantic Structure** - Component names and organization reflect their function, not their appearance
3. **Progressive Complexity** - Start with simple atoms, combine into molecules, assemble into organisms
4. **Token-Driven Styling** - All components use design tokens (`--kol-*`) for automatic theming
5. **Accessibility First** - Every component meets WCAG 2.1 AA standards
6. **Type Safety** - TypeScript definitions ensure component contracts are clear and enforced

## The Three Levels

### Atoms (3.1.x) - Basic Building Blocks

The fundamental, indivisible UI elements that can't be broken down further without losing their meaning.

**Characteristics:**
- Single-purpose components
- No dependencies on other custom components
- Directly map to HTML primitives enhanced with tokens
- Examples: Button, Input, Label, Icon, Avatar

**Current Atoms (packages/ui/src/atoms/):**
- `Button/` - Interactive element for actions
- `Badge/` - Status indicators and labels
- `Avatar/` - User profile representations
- `AspectRatio/` - Media container sizing
- `Checkbox/` - Binary selection input
- `Input/` - Text and data entry fields
- `Label/` - Field identification and descriptions
- `Progress/` - Visual representation of completion
- `RadioGroup/` - Single-selection from multiple options
- `Select/` - Dropdown selection interface
- `Separator/` - Visual divider elements
- `Switch/` - Toggle control for on/off states
- `Textarea/` - Multi-line text input
- `Tooltip/` - Contextual information display
- `SidebarMenuItem/` - Navigation menu entries

**Implementation Pattern:**
```tsx
// Atoms accept semantic tokens and handle their own styling
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'ghost'
  size: 'sm' | 'md' | 'lg'
  children: React.ReactNode
  onClick?: () => void
}

export function Button({ variant, size, children, onClick }: ButtonProps) {
  return (
    <button
      className={cn(
        'kol-button',
        `kol-button-${variant}`,
        `kol-button-${size}`
      )}
      onClick={onClick}
    >
      {children}
    </button>
  )
}
```

### Molecules (3.2.x) - Simple Combinations

Groups of atoms working together as a single unit to perform a specific function.

**Characteristics:**
- Combine 2-5 atoms into a functional unit
- Have their own, clear purpose distinct from individual atoms
- Maintain atomic styling principles (use design tokens)
- Examples: SearchForm (Input + Button), MenuItem (Icon + Text + Badge)

**Current Molecules (packages/ui/src/molecules/):**
- `Card/` - Content container with header, body, footer
- `DropdownMenu/` - Selectable list with trigger
- `Breadcrumbs/` - Navigation path indicator
- `Pagination/` - Page navigation control
- `Alert/` - Message container with type variants
- `Tabs/` - Tabbed content switching
- `NavigationMenu/` - Multi-level navigation
- `Command/` - Command palette interface
- `DataTable/` - Tabular data display
- `SectionToggle/` - Section expand/collapse control
- `StackArticle/` - Article layout wrapper
- `ProseBlock/` - Rich text content container

**Implementation Pattern:**
```tsx
// Molecules compose atoms and add shared logic
export function SearchForm() {
  return (
    <form className="kol-search-form" role="search">
      <Input
        className="kol-search-input"
        placeholder="Search..."
        aria-label="Search"
      />
      <Button variant="primary" size="md">
        Search
      </Button>
    </form>
  )
}
```

### Organisms (3.3.x) - Complex Sections

Distinct, complex sections of the interface that form a standalone part of the interface.

**Characteristics:**
- Combine multiple molecules and/or atoms
- Represent distinct, recognizable sections
- Have clear boundaries and can exist independently
- Examples: Header (Logo + Nav + SearchForm), Sidebar (Logo + NavigationMenu)

**Current Organisms (apps/web/src/components/):**
- `Header/` - Site header with logo, navigation, actions
- `Footer/` - Site footer with links and information
- `Sidebar/` - Navigation sidebar with menu structure
- `BlogPost/` - Full blog article layout
- `HomeHero/` - Homepage hero section
- `FeatureGrid/` - Grid of feature showcases
- `ProductCard/` - Individual product display
- `Cart/` - Shopping cart interface
- `Checkout/` - Multi-step checkout process

**Implementation Pattern:**
```tsx
// Organisms compose molecules and define layout
export function Header() {
  return (
    <header className="kol-header">
      <Logo />
      <NavigationMenu />
      <SearchForm />
      <UserMenu />
    </header>
  )
}
```

## Component Architecture

### Design Tokens Integration

All components use semantic design tokens for styling:

```tsx
// Good - Using tokens
const buttonStyles = {
  backgroundColor: 'var(--kol-accent-primary)',
  color: 'var(--kol-surface-on-primary)',
  padding: 'var(--kol-spacing-md)',
}

// Avoid - Hardcoded values
const badStyles = {
  backgroundColor: '#007bff',
  color: '#ffffff',
  padding: '16px',
}
```

### CSS Layer Architecture

Components use Tailwind's layer system:

```css
/* packages/ui/css/components.css */
@layer components {
  .kol-button {
    /* Base button styles */
  }

  .kol-search-form {
    /* Base search form styles */
  }
}
```

### React Component Structure

Components follow consistent patterns:

```tsx
// File: packages/ui/src/atoms/Button/Button.tsx
import * as React from 'react'
import { cn } from '@/lib/utils'

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost'
  size?: 'sm' | 'md' | 'lg'
  children: React.ReactNode
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'primary', size = 'md', ...props }, ref) => {
    return (
      <button
        className={cn(
          'kol-button',
          `kol-button-${variant}`,
          `kol-button-${size}`,
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = 'Button'
```

### File Organization

```
packages/ui/src/
├── atoms/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.stories.tsx
│   │   └── index.ts
│   ├── Badge/
│   └── ...
├── molecules/
│   ├── Card/
│   │   ├── Card.tsx
│   │   ├── CardHeader.tsx
│   │   ├── CardContent.tsx
│   │   ├── CardFooter.tsx
│   │   ├── Card.stories.tsx
│   │   └── index.ts
│   └── ...
└── ...
```

## Component Categories

### Navigation Components

**Atoms:**
- `SidebarMenuItem/` - Menu entry element

**Molecules:**
- `Breadcrumbs/` - Path navigation
- `NavigationMenu/` - Multi-level menu
- `Pagination/` - Page controls
- `Tabs/` - Content switching
- `Command/` - Command palette

**Organisms:**
- `Header/` - Site navigation
- `Sidebar/` - Side navigation

### Data Display Components

**Atoms:**
- `Avatar/` - User representation
- `Badge/` - Status indicator
- `Progress/` - Completion display
- `Separator/` - Visual divider

**Molecules:**
- `DataTable/` - Tabular data
- `Card/` - Content container

**Organisms:**
- `FeatureGrid/` - Feature showcase
- `ProductCard/` - Product display

### Form Components

**Atoms:**
- `Input/` - Text entry
- `Textarea/` - Multi-line text
- `Checkbox/` - Binary selection
- `RadioGroup/` - Single selection
- `Select/` - Dropdown
- `Switch/` - Toggle
- `Label/` - Field label

**Molecules:**
- `DropdownMenu/` - Selectable options

**Organisms:**
- `Checkout/` - Multi-step form
- `SearchForm/` - Search interface

### Feedback Components

**Molecules:**
- `Alert/` - Message display
- `Tooltip/` - Contextual help

**Organisms:**
- `NotificationCenter/` - Message queue (planned)

## Accessibility Standards

Every component must meet WCAG 2.1 AA standards:

### Semantic HTML

```tsx
// Good - Proper semantics
<nav aria-label="Main navigation">
  <ul>
    <li><a href="/">Home</a></li>
  </ul>
</nav>

// Avoid - Non-semantic divs
<div className="nav">
  <div className="nav-item">
    <div className="nav-link">Home</div>
  </div>
</div>
```

### ARIA Attributes

```tsx
// Use ARIA attributes appropriately
<button
  aria-expanded={isOpen}
  aria-controls="menu-panel"
  aria-haspopup="menu"
>
  Menu
</button>

<div id="menu-panel" role="menu">
  {/* Menu items */}
</div>
```

### Keyboard Navigation

```tsx
// Ensure all interactive elements are keyboard accessible
function MenuItem({ onSelect, children }) {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      onSelect()
    }
  }

  return (
    <div
      role="menuitem"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      onClick={onSelect}
    >
      {children}
    </div>
  )
}
```

### Focus Management

```tsx
// Manage focus appropriately
function Modal({ isOpen, onClose, children }) {
  const modalRef = React.useRef<HTMLDivElement>(null)

  React.useEffect(() => {
    if (isOpen && modalRef.current) {
      // Focus first element when opened
      modalRef.current.querySelector<HTMLElement>('[tabindex]')?.focus()
    }
  }, [isOpen])

  return (
    <div
      ref={modalRef}
      role="dialog"
      aria-modal="true"
      className={cn('kol-modal', isOpen && 'is-open')}
    >
      {children}
    </div>
  )
}
```

## Component Variants and Props

### Variant Pattern

```tsx
// Consistent variant naming across components
type ButtonVariant = 'primary' | 'secondary' | 'ghost' | 'danger'
type BadgeVariant = 'default' | 'success' | 'warning' | 'danger'
type AlertVariant = 'info' | 'success' | 'warning' | 'danger'
```

### Size Pattern

```tsx
// Consistent size naming
type ButtonSize = 'sm' | 'md' | 'lg'
type InputSize = 'sm' | 'md' | 'lg'
```

### Responsive Props

```tsx
// Support responsive props where appropriate
interface ButtonProps {
  size?: 'sm' | 'md' | 'lg'
  sizeSm?: 'sm' | 'md' | 'lg'
  sizeMd?: 'sm' | 'md' | 'lg'
  sizeLg?: 'sm' | 'md' | 'lg'
}
```

## State Management

### Component State

```tsx
// Use React hooks for local state
export function Toggle() {
  const [isOn, setIsOn] = React.useState(false)

  return (
    <button
      aria-pressed={isOn}
      onClick={() => setIsOn(!isOn)}
    >
      {isOn ? 'On' : 'Off'}
    </button>
  )
}
```

### Controlled vs Uncontrolled

```tsx
// Support both patterns
export function Input({
  value,
  defaultValue,
  onValueChange,
  ...props
}: InputProps) {
  const [internalValue, setInternalValue] = React.useState(defaultValue ?? '')

  const isControlled = value !== undefined
  const currentValue = isControlled ? value : internalValue

  const handleChange = (newValue: string) => {
    if (!isControlled) {
      setInternalValue(newValue)
    }
    onValueChange?.(newValue)
  }

  return (
    <input
      value={currentValue}
      onChange={(e) => handleChange(e.target.value)}
      {...props}
    />
  )
}
```

## Composition Patterns

### Compound Components

```tsx
// Allow flexible composition
export function Card({ children }) {
  return <div className="kol-card">{children}</div>
}

Card.Header = function CardHeader({ children }) {
  return <div className="kol-card-header">{children}</div>
}

Card.Content = function CardContent({ children }) {
  return <div className="kol-card-content">{children}</div>
}

Card.Footer = function CardFooter({ children }) {
  return <div className="kol-card-footer">{children}</div>
}

// Usage
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Content>Content</Card.Content>
  <Card.Footer>Footer</Card.Footer>
</Card>
```

### Render Props

```tsx
// For flexible content rendering
export function DataTable({ columns, data, renderRow }) {
  return (
    <table className="kol-table">
      <thead>
        <tr>
          {columns.map((column) => (
            <th key={column.key}>{column.label}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((row) => (
          <tr key={row.id}>
            {renderRow(row)}
          </tr>
        ))}
      </tbody>
    </table>
  )
}
```

## Testing Strategy

### Unit Tests

```tsx
// packages/ui/src/atoms/Button/Button.test.tsx
import { render, screen } from '@testing-library/react'
import { Button } from './Button'

describe('Button', () => {
  it('renders with text', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument()
  })

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    screen.getByRole('button').click()
    expect(handleClick).toHaveBeenCalledTimes(1)
  })
})
```

### Accessibility Tests

```tsx
// Test with jest-axe
import { axe, toHaveNoViolations } from 'jest-axe'
import { render } from '@testing-library/react'

expect.extend(toHaveNoViolations)

it('has no accessibility violations', async () => {
  const { container } = render(<Button>Click me</Button>)
  const results = await axe(container)
  expect(results).toHaveNoViolations()
})
```

### Visual Tests

```tsx
// Storybook stories
// packages/ui/src/atoms/Button/Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react'
import { Button } from './Button'

const meta: Meta<typeof Button> = {
  title: 'Atoms/Button',
  component: Button,
  parameters: {
    layout: 'centered',
  },
}

export default meta
type Story = StoryObj<typeof Button>

export const Primary: Story = {
  args: {
    children: 'Primary Button',
    variant: 'primary',
  },
}

export const Secondary: Story = {
  args: {
    children: 'Secondary Button',
    variant: 'secondary',
  },
}
```

## Performance Considerations

### Code Splitting

```tsx
// Lazy load organisms and complex molecules
const Checkout = React.lazy(() => import('./organisms/Checkout'))
const DataTable = React.lazy(() => import('./molecules/DataTable'))

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Checkout />
    </Suspense>
  )
}
```

### Memoization

```tsx
// Memoize expensive components
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  const processedData = React.useMemo(() => {
    return data.map(expensiveCalculation)
  }, [data])

  return <div>{processedData}</div>
})
```

### Prop Optimization

```tsx
// Use React.callback for event handlers
export function List({ items }) {
  const handleItemClick = React.useCallback((id: string) => {
    // Handle click
  }, [])

  return (
    <ul>
      {items.map((item) => (
        <ListItem
          key={item.id}
          item={item}
          onClick={handleItemClick}
        />
      ))}
    </ul>
  )
}
```

## Implementation Roadmap

### Phase 3.1 - Atoms (In Progress)
- [ ] Audit existing atoms for token compliance
- [ ] Document each atom with props, variants, and examples
- [ ] Add missing accessibility attributes
- [ ] Create comprehensive test coverage

### Phase 3.2 - Molecules (Planned)
- [ ] Document existing molecules
- [ ] Identify missing molecule patterns
- [ ] Create combination guidelines
- [ ] Document composition patterns

### Phase 3.3 - Organisms (Planned)
- [ ] Document existing organisms
- [ ] Create organism composition patterns
- [ ] Document page-level patterns
- [ ] Create layout guidelines

## Related Documentation

**Design System:**
- [2.0.0 Design System: Overview](2.0.0-design-system-overview.md) - Overall philosophy
- [2.1.0 Design System: Colors](2.1.0-design-system-colors.md) - Color tokens
- [2.2.0 Design System: Typography](2.2.0-design-system-typography.md) - Typography scale
- [2.3.0 Design System: CSS Architecture](2.3.0-design-system-css-architecture.md) - Layer structure

**Foundation:**
- [1.0.0 Foundation: Repository Structure](1.0.0-foundation-repository-structure.md) - File organization
- [1.0.1 Foundation: Naming Conventions](1.0.1-foundation-naming-conventions.md) - Naming standards

**Research:**
- [6.1.0 Research: Data Tables](6.1.0-research-data-tables.md) - Component patterns
- [6.2.0 Research: Typography](6.2.0-research-typography.md) - Typography in components

---

## Quick Reference

### Component Decision Tree

```
Is it a single HTML element enhanced with tokens?
├─ Yes → It's an Atom
└─ No

Does it combine 2-5 atoms?
├─ Yes → It's a Molecule
└─ No

Does it form a distinct section of the interface?
├─ Yes → It's an Organism
└─ No → It's a Template (4.x.x)
```

### Naming Conventions

```
Atoms: Noun-based (Button, Input, Avatar)
Molecules: Functional description (SearchForm, DropdownMenu)
Organisms: Page section (Header, Footer, Sidebar)
```

### File Structure

```
packages/ui/src/
├── atoms/          # 3.1.x
├── molecules/      # 3.2.x
└── organisms/      # 3.3.x (planned)
```

---

**Last Updated:** 2025-11-04
**Cross-References:** 2.0.0, 2.1.0, 2.2.0, 2.3.0, 1.0.0, 1.0.1, 6.1.0, 6.2.0
**Category:** Design System
**Status:** Active
